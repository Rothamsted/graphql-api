scalar Point
scalar DateTime
scalar PointInput

"""
Start Base Type
"""
interface baseType {
  iri: String!
  ondexId: ID!
}

# Base Types
type Accession {
  identifier: String!
  iri: String!
  isAmbiguousAccession: String
  publications: [Publication] @relationship(type: "identifier", direction: IN)
  dataSources: [DataSource] @relationship(type: "dataSource", direction: OUT)
  # Consider this relationship
  evidenceTypes: [EvidenceType]
    @relationship(type: "dataSource", direction: OUT)
  proteins: [Protein] @relationship(type: "identifier", direction: IN)
  snps: [SNP] @relationship(type: "identifier", direction: IN)
}

type BioProc implements baseType {
  prefName: String
  description: String
  identifier: String
  iri: String!
  ondexId: ID!
  altName: String
}

type CelComp implements baseType {
  description: String!
  prefName: String!
  identifier: String!
  iri: String!
  ondexId: ID!
  altName: String
}

type CoExpCluster implements baseType {
  prefName: String!
  iri: String!
  ondexId: ID!
}

# Little Records
type CoExpStudy {
  prefName: String!
  iri: String!
  Method: String!
  Authors: String!
  ondexId: ID!
  Title: String
}

type Comp implements baseType {
  prefName: String!
  Mr: Float
  description: String
  identifier: String!
  iri: String!
  ondexId: ID!
  CML: String
  altName: String
}

type Concept {
  prefName: String
  Chemical: String
  Abstract: String
  ondexId: ID!
  AUTHORS: String
  MeSH: String
  identifier: String
  YEAR: Int
  AbstractHeader: String
  JOURNAL_REF: String
  iri: String!
  PUB_TYPE: String
  comment: String
  testAttribute: String
  BEGIN: Int
  TAXID: Int
  Chromosome: Int
  END: Int
  altName: String
  description: String
  AA: String
  Description: String
  Method: String
  Authors: String
  Title: String
  T3_Description: String
  Study: String
  Phenotype: String
  Pheno: String
  Position: String
  Mr: String
  CML: String
}

type DataSource {
  label: String
  identifier: String!
  iri: String!
  description: String
  accessions: [Accession] @relationship(type: "dataSource", direction: IN)
}

type EC implements baseType {
  prefName: String
  identifier: String!
  iri: String!
  ondexId: ID!
}

type Enzyme implements baseType {
  prefName: String!
  identifier: String!
  iri: String!
  ondexId: ID!
  description: String
  altName: String
}

type EvidenceType {
  label: String
  identifier: String!
  iri: String!
  description: String
  proteins: [Protein] @relationship(type: "evidence", direction: IN)
  # Consider this relationship
  accessions: [Accession] @relationship(type: "dataSource", direction: IN)
  snps: [SNP] @relationship(type: "evidence", direction: IN)
}

type Gene implements baseType {
  iri: String!
  identifier: String
  TAXID: Int
  Chromosome: Int
  END: Int
  comment: String
  ondexId: ID!
  BEGIN: Int
  altName: String
  prefName: String
  publications: [Publication] @relationship(type: "pub_in", direction: OUT)
  proteins: [Protein] @relationship(type: "enc", direction: OUT)
  genes: [Gene] @relationship(type: "regulates", direction: OUT)
}

type MolFunc implements baseType {
  prefName: String
  altName: String
  description: String
  identifier: String!
  iri: String!
  ondexId: ID!
}

type Path implements baseType {
  description: String
  identifier: String
  iri: String!
  ondexId: ID!
  prefName: String
  altName: String
}

type Phenotype implements baseType {
  iri: String!
  ondexId: ID!
  Phenotype: String
}

type PlantOntologyTerm implements baseType {
  ondexId: ID!
  prefName: String
  description: String
  identifier: String!
  altName: String
  iri: String!
}

type ProtDomain implements baseType {
  prefName: String
  Description: String
  iri: String!
  ondexId: ID!
  proteins: [Protein] @relationship(type: "has_domain", direction: IN)
}

type Protcmplx implements baseType {
  TAXID: Int
  prefName: String
  description: String
  identifier: String!
  altName: String
  iri: String!
  ondexId: ID!
}

type Protein implements baseType {
  prefName: String
  AA: String
  ondexId: ID!
  TAXID: Int
  identifier: String
  iri: String!
  comment: String
  altName: String
  description: String
  Pheno: String
  protDomains: [ProtDomain] @relationship(type: "has_domain", direction: OUT)
  evidenceTypes: [EvidenceType] @relationship(type: "evidence", direction: OUT)
  accessions: [Accession] @relationship(type: "identifier", direction: OUT)
  publications: [Publication] @relationship(type: "pub_in", direction: OUT)
  genes: [Gene] @relationship(type: "enc", direction: IN)
  proteins: [Protein] @relationship(type: "h_s_s", direction: OUT)
}

type Publication implements baseType {
  prefName: String
  Chemical: String
  Abstract: String
  ondexId: ID!
  AUTHORS: String
  MeSH: String
  identifier: String
  YEAR: Int
  AbstractHeader: String
  JOURNAL_REF: String
  iri: String!
  PUB_TYPE: String
  comment: String
  accessions: [Accession] @relationship(type: "identifier", direction: OUT)
  dataSources: [DataSource] @relationship(type: "dataSource", direction: OUT)
  genes: [Gene] @relationship(type: "pub_in", direction: IN)
  proteins: [Protein] @relationship(type: "pub_in", direction: IN)
}

type Reaction {
  prefName: String
  identifier: String
  iri: String!
  ondexId: ID!
  altName: String
  description: String
}

type Resource {
  prefName: String
  Chemical: String
  Abstract: String
  ondexId: ID
  AUTHORS: String
  MeSH: String
  identifier: String
  YEAR: Int
  AbstractHeader: String
  JOURNAL_REF: String
  iri: String!
  PUB_TYPE: String
  comment: String
  testAttribute: String
  BEGIN: Int
  TAXID: Int
  Chromosome: String
  END: Int
  altName: String
  description: String
  AA: String
  Description: String
  Method: String
  Authors: String
  Title: String
  T3_Description: String
  Study: String
  Phenotype: String
  Pheno: String
  Position: String
  Mr: String
  CML: String
  label: String
  isAmbiguousAccession: String
}

type SNP implements baseType {
  iri: String!
  ondexId: ID!
  Position: String
  prefName: String
  END: Int
  BEGIN: Int
  TAXID: Int
  Chromosome: String
  evidenceTypes: [EvidenceType] @relationship(type: "evidence", direction: OUT)
  accessions: [Accession] @relationship(type: "identifier", direction: OUT)
}

type SNPEffect implements baseType {
  iri: String!
  ondexId: ID!
}

type Trait implements baseType {
  prefName: String
  description: String
  identifier: String
  iri: String!
  ondexId: ID!
  altName: String
  T3_Description: String
  Study: String
}

type Transport implements baseType {
  prefName: String
  identifier: String!
  iri: String!
  ondexId: ID!
  altName: String
  description: String
}

"""
The Definition of Base Types End
Start Custom Query
"""
type RankedGene {
  ondexId: Int!
  accession: String!
  geneName: String!
  chro: Int!
  start: Int
  taxId: Int!
  score: Float!
  user: String!
  qtlEvidence: String!
}

type Query {
  GetRankedGenes(keyword: String, list: String): [RankedGene]!
}

type User {
  userId: ID!
  name: String
  reviews: [Review] @relationship(type: "WROTE", direction: OUT)
  avgStars: Float
    @cypher(
      statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN toFloat(avg(r.stars))"
    )
  numReviews: Int
    @cypher(statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN COUNT(r)")
  recommendations(first: Int = 3): [Business]
    @cypher(
      statement: "MATCH (this)-[:WROTE]->(r:Review)-[:REVIEWS]->(:Business)<-[:REVIEWS]-(:Review)<-[:WROTE]-(:User)-[:WROTE]->(:Review)-[:REVIEWS]->(rec:Business) WHERE NOT EXISTS( (this)-[:WROTE]->(:Review)-[:REVIEWS]->(rec) ) WITH rec, COUNT(*) AS num ORDER BY num DESC LIMIT $first RETURN rec"
    )
}

type Business {
  businessId: ID!
  name: String!
  address: String
  city: String
  state: String
  location: Point
  avgStars: Float
    @cypher(
      statement: "MATCH (this)<-[:REVIEWS]-(r:Review) RETURN coalesce(avg(r.stars),0.0)"
    )
  reviews: [Review] @relationship(type: "REVIEWS", direction: IN)
  categories: [Category] @relationship(type: "IN_CATEGORY", direction: OUT)
}

type Review {
  reviewId: ID!
  stars: Float
  text: String
  date: DateTime
  business: Business @relationship(type: "REVIEWS", direction: OUT)
  user: User @relationship(type: "WROTE", direction: IN)
}

type Category {
  name: ID!
  businesses: [Business] @relationship(type: "IN_CATEGORY", direction: IN)
}

type RatingCount @exclude {
  stars: Float!
  count: Int!
}

type Mutation {
  mergeBusinessCategory(categories: [String!]!, businessId: ID!): Business
    @cypher(
      statement: "MATCH (b:Business {businessId: $businessId}) UNWIND $categories AS cat MERGE (c:Category {name: cat}) MERGE (b)-[:IN_CATEGORY]->(c) RETURN b"
    )
  mergeUser(name: String!, userId: ID!): User
    @cypher(
      statement: """
      MERGE (u:User {userId: $userId})
      ON CREATE SET u.name = $name
      RETURN u
      """
    )
  mergeBusiness(
    businessId: ID!
    name: String!
    address: String!
    city: String!
    state: String!
    latitude: Float!
    longitude: Float!
  ): Business
    @cypher(
      statement: """
      MERGE (b:Business {businessId: $businessId})
      ON CREATE SET b.name = $name,
                    b.address = $address,
                    b.city = $city,
                    b.state = $state,
                    b.location = Point({latitude: $latitude, longitude: $longitude})
      RETURN b
      """
    )
}

# type Query {
#   userCount: Int! @cypher(statement: "MATCH (u:User) RETURN COUNT(u)")
#   ratingsCount: [RatingCount]
#     @cypher(
#       statement: "MATCH (r:Review) WITH r.stars AS stars, COUNT(*) AS count ORDER BY stars RETURN {stars: stars, count: count}"
#     )
# }
