"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.mapParameters = exports.translateNestedMutations = void 0;

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _fields = require("../../augment/fields");

var _directives = require("../../augment/directives");

var _graphql = require("graphql");

var _lodash = _interopRequireDefault(require("lodash"));

var translateNestedMutations = function translateNestedMutations(_ref) {
  var _ref$inputFields = _ref.inputFields,
      inputFields = _ref$inputFields === void 0 ? [] : _ref$inputFields,
      _ref$parameterData = _ref.parameterData,
      parameterData = _ref$parameterData === void 0 ? {} : _ref$parameterData,
      _ref$paramVariable = _ref.paramVariable,
      paramVariable = _ref$paramVariable === void 0 ? '' : _ref$paramVariable,
      parameterMap = _ref.parameterMap,
      _ref$parentFieldName = _ref.parentFieldName,
      parentFieldName = _ref$parentFieldName === void 0 ? '' : _ref$parentFieldName,
      _ref$parentIsListArgu = _ref.parentIsListArgument,
      parentIsListArgument = _ref$parentIsListArgu === void 0 ? false : _ref$parentIsListArgu,
      _ref$isListArgument = _ref.isListArgument,
      isListArgument = _ref$isListArgument === void 0 ? false : _ref$isListArgument,
      _ref$isRootArgument = _ref.isRootArgument,
      isRootArgument = _ref$isRootArgument === void 0 ? false : _ref$isRootArgument,
      _ref$rootUsesListVari = _ref.rootUsesListVariable,
      rootUsesListVariable = _ref$rootUsesListVari === void 0 ? false : _ref$rootUsesListVari,
      _ref$rootStatement = _ref.rootStatement,
      rootStatement = _ref$rootStatement === void 0 ? '' : _ref$rootStatement,
      _ref$typeMap = _ref.typeMap,
      typeMap = _ref$typeMap === void 0 ? {} : _ref$typeMap;

  if (!_lodash["default"].isObject(parameterMap)) {
    parameterMap = mapParameters(parameterData);
    isRootArgument = true;
  }

  return inputFields.reduce(function (translations, field) {
    var name = field.name,
        type = field.type;
    var fieldName = name.value;
    var unwrappedType = (0, _fields.unwrapNamedType)({
      type: type
    });
    var inputTypeName = unwrappedType.name;
    var inputTypeWrappers = unwrappedType.wrappers;
    var inputType = typeMap[inputTypeName];
    var nestedParameterMap = parameterMap[fieldName];

    if ((0, _graphql.isInputObjectType)(inputType) && _lodash["default"].isObject(nestedParameterMap)) {
      var _decideCypherParamete = decideCypherParameterArity({
        rootStatement: rootStatement,
        fieldName: fieldName,
        inputTypeName: inputTypeName,
        inputTypeWrappers: inputTypeWrappers,
        paramVariable: paramVariable,
        isRootArgument: isRootArgument,
        rootUsesListVariable: rootUsesListVariable,
        isListArgument: isListArgument
      });

      var _decideCypherParamete2 = (0, _slicedToArray2["default"])(_decideCypherParamete, 2);

      isListArgument = _decideCypherParamete2[0];
      rootUsesListVariable = _decideCypherParamete2[1];
      var cypherDirective = (0, _directives.getDirective)({
        directives: field.directives,
        name: _directives.DirectiveDefinition.CYPHER
      }); // get the path to the parameter data to iterate over

      var nestedParamVariable = decideCypherParameter({
        paramVariable: paramVariable,
        fieldName: fieldName,
        inputTypeName: inputTypeName,
        cypherDirective: cypherDirective,
        isRootArgument: isRootArgument,
        rootUsesListVariable: rootUsesListVariable
      });

      if (cypherDirective) {
        // wrap this Cypher statement in a subquery
        // and recurse for any nested @cypher fields
        var translated = translateNestedMutation({
          paramVariable: nestedParamVariable,
          parameterMap: nestedParameterMap,
          cypherDirective: cypherDirective,
          inputType: inputType,
          inputTypeName: inputTypeName,
          isListArgument: isListArgument,
          parentIsListArgument: parentIsListArgument,
          parentFieldName: parentFieldName,
          fieldName: fieldName,
          isRootArgument: isRootArgument,
          rootUsesListVariable: rootUsesListVariable,
          typeMap: typeMap
        });

        if (translated) {
          translations.push(translated);
        }
      } else {
        // continue looking for sibling @cypher fields
        var nestedStatements = translateNestedMutations({
          inputFields: getFieldAstNodes(inputType),
          paramVariable: nestedParamVariable,
          parentFieldName: fieldName,
          parentIsListArgument: isListArgument,
          parameterMap: nestedParameterMap,
          isRootArgument: isRootArgument,
          rootUsesListVariable: rootUsesListVariable,
          rootStatement: rootStatement,
          typeMap: typeMap
        });

        if (nestedStatements) {
          // these subqueries are siblings within this scope,
          // but have longer paths to nested @cypher fields
          translations.push(nestedStatements);
        }
      }
    }

    return translations;
  }, []).join('\n');
};

exports.translateNestedMutations = translateNestedMutations;

var translateNestedMutation = function translateNestedMutation(_ref2) {
  var paramVariable = _ref2.paramVariable,
      parameterMap = _ref2.parameterMap,
      inputType = _ref2.inputType,
      inputTypeName = _ref2.inputTypeName,
      cypherDirective = _ref2.cypherDirective,
      fieldName = _ref2.fieldName,
      typeMap = _ref2.typeMap,
      parentIsListArgument = _ref2.parentIsListArgument,
      parentFieldName = _ref2.parentFieldName,
      isRootArgument = _ref2.isRootArgument,
      isListArgument = _ref2.isListArgument,
      rootUsesListVariable = _ref2.rootUsesListVariable;
  // recurse to handle child @cypher input
  var nestedStatements = translateNestedMutations({
    inputFields: getFieldAstNodes(inputType),
    paramVariable: inputTypeName,
    parentIsListArgument: isListArgument,
    parentFieldName: fieldName,
    parameterMap: parameterMap,
    typeMap: typeMap
  });
  var cypherStatement = augmentWithClauses({
    cypherDirective: cypherDirective,
    inputTypeName: inputTypeName,
    nestedStatements: nestedStatements
  }); // the parameter data for this @cypher field is iterated
  // over using a Cypher UNWIND clause

  var unwindClause = decideUnwindClause({
    fieldName: fieldName,
    inputTypeName: inputTypeName,
    parentIsListArgument: parentIsListArgument,
    parentFieldName: parentFieldName,
    paramVariable: paramVariable,
    isRootArgument: isRootArgument,
    rootUsesListVariable: rootUsesListVariable
  });
  var openVariableScope = "WITH *";
  var closeVariableScope = "RETURN COUNT(*) AS _".concat(parentFieldName ? "".concat(parentFieldName, "_") : '').concat(fieldName, "_");
  return "\nCALL {\n  ".concat(openVariableScope, "\n  ").concat(unwindClause, "\n  ").concat(cypherStatement).concat(nestedStatements, "\n  ").concat(closeVariableScope, "\n}");
};

var decideCypherParameterArity = function decideCypherParameterArity(_ref3) {
  var _ref3$rootStatement = _ref3.rootStatement,
      rootStatement = _ref3$rootStatement === void 0 ? '' : _ref3$rootStatement,
      _ref3$fieldName = _ref3.fieldName,
      fieldName = _ref3$fieldName === void 0 ? '' : _ref3$fieldName,
      _ref3$inputTypeName = _ref3.inputTypeName,
      inputTypeName = _ref3$inputTypeName === void 0 ? '' : _ref3$inputTypeName,
      _ref3$inputTypeWrappe = _ref3.inputTypeWrappers,
      inputTypeWrappers = _ref3$inputTypeWrappe === void 0 ? {} : _ref3$inputTypeWrappe,
      _ref3$paramVariable = _ref3.paramVariable,
      paramVariable = _ref3$paramVariable === void 0 ? '' : _ref3$paramVariable,
      _ref3$isRootArgument = _ref3.isRootArgument,
      isRootArgument = _ref3$isRootArgument === void 0 ? false : _ref3$isRootArgument,
      _ref3$rootUsesListVar = _ref3.rootUsesListVariable,
      rootUsesListVariable = _ref3$rootUsesListVar === void 0 ? false : _ref3$rootUsesListVar,
      _ref3$isListArgument = _ref3.isListArgument,
      isListArgument = _ref3$isListArgument === void 0 ? false : _ref3$isListArgument;

  if (isRootArgument) {
    isListArgument = inputTypeWrappers[_fields.TypeWrappers.LIST_TYPE];

    if (!paramVariable) {
      // These properties are used to identify cases where the root
      // Cypher statement of a @cypher mutation already unwinds a list
      // argument containing nested @cypher fields
      rootUsesListVariable = includesCypherUnwindClause({
        typeName: inputTypeName,
        fieldName: fieldName,
        statement: rootStatement
      });
    }
  }

  return [isListArgument, rootUsesListVariable];
};

var includesCypherUnwindClause = function includesCypherUnwindClause(_ref4) {
  var _ref4$typeName = _ref4.typeName,
      typeName = _ref4$typeName === void 0 ? '' : _ref4$typeName,
      _ref4$fieldName = _ref4.fieldName,
      fieldName = _ref4$fieldName === void 0 ? '' : _ref4$fieldName,
      _ref4$statement = _ref4.statement,
      statement = _ref4$statement === void 0 ? '' : _ref4$statement;
  var unwindRegExp = new RegExp("\\s*\\UNWIND\\s*\\$".concat(fieldName, "\\s*\\AS\\s*").concat(typeName), 'i');
  var matched = statement.match(unwindRegExp);
  var hasUnwindClause = false;

  if (matched) {
    var match = matched[0];
    var includesParameter = match.includes("$".concat(fieldName));
    var includesVariable = match.includes(typeName);

    if (includesParameter && includesVariable) {
      hasUnwindClause = true;
    }
  }

  return hasUnwindClause;
};

var decideCypherParameter = function decideCypherParameter(_ref5) {
  var paramVariable = _ref5.paramVariable,
      inputTypeName = _ref5.inputTypeName,
      fieldName = _ref5.fieldName,
      cypherDirective = _ref5.cypherDirective,
      isRootArgument = _ref5.isRootArgument,
      rootUsesListVariable = _ref5.rootUsesListVariable;

  if (paramVariable) {
    if (cypherDirective) {
      if (isRootArgument) {
        if (!rootUsesListVariable) {
          // Cypher parameter prefix
          return "$".concat(paramVariable);
        }

        return paramVariable;
      } // prefixed with _ to correspond to alias
      // of parent UNWIND variable


      return "_".concat(paramVariable, ".").concat(fieldName);
    }

    return "".concat(paramVariable, ".").concat(fieldName);
  }

  if (rootUsesListVariable) {
    // root @cypher mutation unwinds this argument
    // so continue with its Cypher variable
    return inputTypeName;
  }

  return fieldName;
};

var decideUnwindClause = function decideUnwindClause(_ref6) {
  var fieldName = _ref6.fieldName,
      inputTypeName = _ref6.inputTypeName,
      parentFieldName = _ref6.parentFieldName,
      parentIsListArgument = _ref6.parentIsListArgument,
      paramVariable = _ref6.paramVariable,
      isRootArgument = _ref6.isRootArgument,
      rootUsesListVariable = _ref6.rootUsesListVariable;

  if (isRootArgument) {
    if (parentIsListArgument && !rootUsesListVariable) {
      // two-dimensional unwind for root list arguments
      // not already unwound by the root Cypher statement
      return "UNWIND ".concat(paramVariable, " AS _").concat(parentFieldName, "\n  UNWIND _").concat(parentFieldName, ".").concat(fieldName, " as ").concat(inputTypeName);
    }

    return "UNWIND ".concat(paramVariable, ".").concat(fieldName, " AS ").concat(inputTypeName);
  }

  return "UNWIND ".concat(paramVariable, " AS ").concat(inputTypeName);
};

var augmentWithClauses = function augmentWithClauses(_ref7) {
  var _ref7$inputTypeName = _ref7.inputTypeName,
      inputTypeName = _ref7$inputTypeName === void 0 ? '' : _ref7$inputTypeName,
      _ref7$nestedStatement = _ref7.nestedStatements,
      nestedStatements = _ref7$nestedStatement === void 0 ? [] : _ref7$nestedStatement,
      cypherDirective = _ref7.cypherDirective;
  var statement = (0, _directives.getDirectiveArgument)({
    directive: cypherDirective,
    name: 'statement'
  });
  var openingWithClause = '';
  var endingWithClause = '';

  if (statement) {
    var lowercasedStatement = statement.toLowerCase();
    var isCommentedRegExp = new RegExp("with(?!/*.*)", 'i');
    var firstWithIndex = lowercasedStatement.indexOf('with');
    isCommentedRegExp.lastIndex = firstWithIndex;
    var lastWithIndex = lowercasedStatement.lastIndexOf('with'); // this makes the regex match "sticky", which begins the match from the given index

    isCommentedRegExp.lastIndex = lastWithIndex;

    if (firstWithIndex !== -1) {
      var firstWithMatch = statement.substr(firstWithIndex); // so, to determine which is at the top, see that the index is actually 0, test this

      if (firstWithMatch) {
        // there is only one WITH clause
        if (firstWithIndex === lastWithIndex) {
          var onlyMatch = statement.substr(firstWithIndex);

          if (firstWithIndex === 0) {
            // the only WITH clause also begins at index 0, so it's an opening WITH clause
            openingWithClause = onlyMatch;
          } else {
            // assume the last WITH clause is at the end of the statement
            endingWithClause = onlyMatch;
          }
        } else if (lastWithIndex !== -1) {
          // there are two or more WITH clauses
          var firstMatch = statement.substr(firstWithIndex);
          var lastMatch = statement.substr(lastWithIndex);
          if (firstWithIndex === 0) openingWithClause = firstMatch;
          endingWithClause = lastMatch;
        }

        if (openingWithClause && endingWithClause) {
          openingWithClause = openingWithClause.substr(0, lastWithIndex);
        }

        if (openingWithClause) {
          // add a Cypher variable for inputTypeName - the name of the parent
          // UNWIND variable - to keep it available within the proceeding Cypher
          statement = augmentWithClause({
            withClause: openingWithClause,
            inputTypeName: inputTypeName,
            isImportClause: true
          });
        }

        if (endingWithClause) {
          // add an alias for the Cypher variable from the parent UNWIND statement,
          // to allow the same input type to be used again by a nested UNWIND,
          // preventing variable name conflicts
          var augmentedWithClause = augmentWithClause({
            withClause: endingWithClause,
            inputTypeName: inputTypeName,
            isExportClause: true
          });

          if (openingWithClause) {
            // if there is also a WITH clause importing variables,
            // then it has already been augmented (above) and equal to statement,
            // so the now augmented exporting WITH clause is appended
            statement = "".concat(statement).concat(augmentedWithClause);
          } else {
            // otherwise, statement is still unmodified, so get everything before
            // the exporting WITH clause, appending after it the augmented clause
            var beforeEndingWith = statement.substr(0, lastWithIndex);
            statement = "".concat(beforeEndingWith, "\n").concat(augmentedWithClause);
          }
        }
      }
    }
  }

  if (!endingWithClause && nestedStatements.length) {
    var paramVariable = "".concat(inputTypeName, " AS _").concat(inputTypeName); // continue with all Cypher variables in scope and an alias of the input type

    endingWithClause = "WITH *, ".concat(paramVariable);
    statement = "".concat(statement, "\n").concat(endingWithClause);
  }

  return statement;
};

var augmentWithClause = function augmentWithClause(_ref8) {
  var _ref8$withClause = _ref8.withClause,
      withClause = _ref8$withClause === void 0 ? '' : _ref8$withClause,
      _ref8$inputTypeName = _ref8.inputTypeName,
      inputTypeName = _ref8$inputTypeName === void 0 ? '' : _ref8$inputTypeName,
      _ref8$isImportClause = _ref8.isImportClause,
      isImportClause = _ref8$isImportClause === void 0 ? false : _ref8$isImportClause,
      _ref8$isExportClause = _ref8.isExportClause,
      isExportClause = _ref8$isExportClause === void 0 ? false : _ref8$isExportClause;
  // find the index of the first comma, for checking if this is a variable list
  var firstCommaIndex = withClause.indexOf(','); // regex to check if this clause begins with the pattern WITH *

  var withEverythingRegex = new RegExp("WITH\\s*\\*+", 'i');
  var continuesWithEverything = withClause.match(withEverythingRegex); // assume the clause is not a variable list, e.g., WITH *, ... or WITH x, ...

  var isVariableList = false; // assume the clause does not begin with WITH *

  var isWithAsterisk = false;
  var augmentedWithClause = withClause; // remove the WITH from the beginning of the clause

  var withClauseRemainder = withClause.substr(4);

  if (continuesWithEverything) {
    isWithAsterisk = true;
    var match = continuesWithEverything[0];
    var matchLen = match.length; // get everything proceeding WITH *

    var nextCypher = withClause.substr(matchLen);

    if (nextCypher) {
      // trim everything proceeding, so we can check the next character
      // using String.startsWith
      var trimmed = nextCypher.trim();

      if (trimmed.startsWith(',') && firstCommaIndex !== -1) {
        // if the clause begins with WITH * and is immediately proceeded
        // by a comma, the clause begins as: "WITH *, ..."
        isVariableList = true;
      }
    }
  }

  var paramVariable = '';

  if (isImportClause) {
    // if an importating WITH clause is provided, then we need to persist
    // the parent UNWIND clause's variable along with it to keep it available
    paramVariable = inputTypeName;
  } else if (isExportClause) {
    // alias this input type name for it to be unwound by the nested UNWIND,
    // to allow for reusing the same input type in nested cases
    paramVariable = "".concat(inputTypeName, " AS _").concat(inputTypeName);
  }

  if (isWithAsterisk) {
    if (isVariableList) {
      // set withClauseRemainder forward to start at the first comma
      withClauseRemainder = withClause.substr(firstCommaIndex);
    } else {
      // set withClauseRemainder to immediately after WITH *
      withClauseRemainder = withClause.substr(6);
    } // inject paramVariable into the clause


    augmentedWithClause = "WITH *, ".concat(paramVariable).concat(withClauseRemainder);
  } else {
    // otherwise, the clause is not WITH * and not a list, as neither "WITH *", nor "WITH x, ..."
    // so it is added with a preceeding comma, assuming the clause provides at least 1 variable
    augmentedWithClause = "WITH ".concat(paramVariable).concat(withClauseRemainder ? ",".concat(withClauseRemainder) : '');
  }

  return augmentedWithClause;
};

var mapParameters = function mapParameters() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // reduce parameter json to a json with keys only for object
  // and array values, used to identify usage of @cypher input
  return (0, _entries["default"])(params).reduce(function (mapped, _ref9) {
    var _ref10 = (0, _slicedToArray2["default"])(_ref9, 2),
        name = _ref10[0],
        param = _ref10[1];

    var mappedParam = mapParameter(param);

    if (mappedParam) {
      mapped[name] = mappedParam;
    }

    return mapped;
  }, {});
};

exports.mapParameters = mapParameters;

var mapParameter = function mapParameter(param) {
  if (_lodash["default"].isArray(param)) {
    // object type list field
    if (_lodash["default"].isObject(param[0])) {
      // after graphql validation, all values
      // in this array should also be objects
      return param.reduce(function (mapped, params) {
        return _lodash["default"].merge(mapped, mapParameters(params));
      }, {});
    } // scalar list field

  } else if (_lodash["default"].isObject(param)) {
    return mapParameters(param);
  } // scalar field / null

};

var getFieldAstNodes = function getFieldAstNodes(type) {
  return (0, _values["default"])(type.getFields()).map(function (field) {
    return field.astNode;
  });
};