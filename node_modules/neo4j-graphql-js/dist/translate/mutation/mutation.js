"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.translateMutation = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _utils = require("../../utils");

var _selection = require("../../augment/types/node/selection");

var _graphql = require("graphql");

var _selections = require("../../selections");

var _lodash = _interopRequireDefault(require("lodash"));

var _types = require("../../augment/types/types");

var _fields = require("../../augment/fields");

var _inputValues2 = require("../../augment/input-values");

var _translate = require("../translate");

var _apolloServerErrors = require("apollo-server-errors");

var _inputValues3 = require("./input-values");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Mutation API root operation branch
var translateMutation = function translateMutation(_ref) {
  var resolveInfo = _ref.resolveInfo,
      context = _ref.context,
      first = _ref.first,
      offset = _ref.offset,
      otherParams = _ref.otherParams;
  var typeMap = resolveInfo.schema.getTypeMap();

  var _typeIdentifiers = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers.typeName,
      variableName = _typeIdentifiers.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);
  var selections = (0, _utils.getPayloadSelections)(resolveInfo);
  var outerSkipLimit = (0, _utils.getOuterSkipLimit)(first, offset);
  var orderByValue = (0, _utils.computeOrderBy)(resolveInfo, schemaType);
  var additionalNodeLabels = (0, _utils.getAdditionalLabels)(schemaType, (0, _translate.getCypherParams)(context));
  var mutationTypeCypherDirective = (0, _utils.getMutationCypherDirective)(resolveInfo);
  var mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
    return x.name.value === 'MutationMeta';
  });
  var fieldArguments = (0, _utils.getMutationArguments)(resolveInfo);
  var serializedParams = (0, _inputValues2.analyzeMutationArguments)({
    fieldArguments: fieldArguments,
    values: otherParams,
    resolveInfo: resolveInfo
  });
  var params = (0, _utils.initializeMutationParams)({
    mutationMeta: mutationMeta,
    resolveInfo: resolveInfo,
    mutationTypeCypherDirective: mutationTypeCypherDirective,
    first: first,
    otherParams: serializedParams,
    offset: offset
  });
  var isInterfaceType = (0, _utils.isGraphqlInterfaceType)(schemaType);
  var isObjectType = (0, _utils.isGraphqlObjectType)(schemaType);
  var isUnionType = (0, _utils.isGraphqlUnionType)(schemaType);
  var usesFragments = (0, _selections.isFragmentedSelection)({
    selections: selections
  });
  var isFragmentedObjectType = usesFragments && isObjectType;
  var isFragmentedInterfaceType = usesFragments && isInterfaceType;
  var interfaceLabels = typeof schemaType.getInterfaces === 'function' ? schemaType.getInterfaces().map(function (i) {
    return i.name;
  }) : [];
  var unionLabels = getUnionLabels({
    typeName: typeName,
    typeMap: typeMap
  });
  var additionalLabels = [].concat((0, _toConsumableArray2["default"])(additionalNodeLabels), (0, _toConsumableArray2["default"])(interfaceLabels), (0, _toConsumableArray2["default"])(unionLabels));

  var _mergeSelectionFragme = (0, _selections.mergeSelectionFragments)({
    schemaType: schemaType,
    selections: selections,
    isFragmentedObjectType: isFragmentedObjectType,
    isFragmentedInterfaceType: isFragmentedInterfaceType,
    isUnionType: isUnionType,
    typeMap: typeMap,
    resolveInfo: resolveInfo
  }),
      _mergeSelectionFragme2 = (0, _slicedToArray2["default"])(_mergeSelectionFragme, 2),
      schemaTypeFields = _mergeSelectionFragme2[0],
      derivedTypeMap = _mergeSelectionFragme2[1];

  var translation = "";
  var translationParams = {};

  if (mutationTypeCypherDirective) {
    var _customMutation = customMutation({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      schemaTypeFields: schemaTypeFields,
      derivedTypeMap: derivedTypeMap,
      isObjectType: isObjectType,
      isInterfaceType: isInterfaceType,
      isUnionType: isUnionType,
      usesFragments: usesFragments,
      selections: selections,
      params: params,
      context: context,
      mutationTypeCypherDirective: mutationTypeCypherDirective,
      variableName: variableName,
      orderByValue: orderByValue,
      outerSkipLimit: outerSkipLimit,
      typeMap: typeMap
    });

    var _customMutation2 = (0, _slicedToArray2["default"])(_customMutation, 2);

    translation = _customMutation2[0];
    translationParams = _customMutation2[1];
  } else if ((0, _utils.isCreateMutation)(resolveInfo)) {
    var _nodeCreate = nodeCreate({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context,
      variableName: variableName,
      typeName: typeName,
      additionalLabels: additionalLabels,
      typeMap: typeMap
    });

    var _nodeCreate2 = (0, _slicedToArray2["default"])(_nodeCreate, 2);

    translation = _nodeCreate2[0];
    translationParams = _nodeCreate2[1];
  } else if ((0, _utils.isDeleteMutation)(resolveInfo)) {
    var _nodeDelete = nodeDelete({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      variableName: variableName,
      typeName: typeName,
      typeMap: typeMap
    });

    var _nodeDelete2 = (0, _slicedToArray2["default"])(_nodeDelete, 2);

    translation = _nodeDelete2[0];
    translationParams = _nodeDelete2[1];
  } else if ((0, _utils.isAddMutation)(resolveInfo)) {
    var _relationshipCreate = relationshipCreate({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context
    });

    var _relationshipCreate2 = (0, _slicedToArray2["default"])(_relationshipCreate, 2);

    translation = _relationshipCreate2[0];
    translationParams = _relationshipCreate2[1];
  } else if ((0, _utils.isUpdateMutation)(resolveInfo) || (0, _utils.isMergeMutation)(resolveInfo)) {
    /**
     * TODO: Once we are no longer using the @MutationMeta directive
     * on relationship mutations, we will need to more directly identify
     * whether this Merge mutation if for a node or relationship
     */
    if (mutationMeta) {
      var _relationshipMergeOrU = relationshipMergeOrUpdate({
        mutationMeta: mutationMeta,
        resolveInfo: resolveInfo,
        selections: selections,
        schemaType: schemaType,
        params: params,
        context: context
      });

      var _relationshipMergeOrU2 = (0, _slicedToArray2["default"])(_relationshipMergeOrU, 2);

      translation = _relationshipMergeOrU2[0];
      translationParams = _relationshipMergeOrU2[1];
    } else {
      var _nodeMergeOrUpdate = nodeMergeOrUpdate({
        resolveInfo: resolveInfo,
        variableName: variableName,
        typeName: typeName,
        selections: selections,
        schemaType: schemaType,
        additionalLabels: additionalLabels,
        params: params,
        context: context,
        typeMap: typeMap
      });

      var _nodeMergeOrUpdate2 = (0, _slicedToArray2["default"])(_nodeMergeOrUpdate, 2);

      translation = _nodeMergeOrUpdate2[0];
      translationParams = _nodeMergeOrUpdate2[1];
    }
  } else if ((0, _utils.isRemoveMutation)(resolveInfo)) {
    var _relationshipDelete = relationshipDelete({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context
    });

    var _relationshipDelete2 = (0, _slicedToArray2["default"])(_relationshipDelete, 2);

    translation = _relationshipDelete2[0];
    translationParams = _relationshipDelete2[1];
  } else {
    // throw error - don't know how to handle this type of mutation
    throw new _apolloServerErrors.ApolloError('Do not know how to handle this type of mutation. Mutation does not follow naming convention.');
  }

  return [translation, translationParams];
}; // Custom write operation


exports.translateMutation = translateMutation;

var customMutation = function customMutation(_ref2) {
  var params = _ref2.params,
      context = _ref2.context,
      mutationTypeCypherDirective = _ref2.mutationTypeCypherDirective,
      selections = _ref2.selections,
      variableName = _ref2.variableName,
      schemaType = _ref2.schemaType,
      schemaTypeFields = _ref2.schemaTypeFields,
      derivedTypeMap = _ref2.derivedTypeMap,
      isObjectType = _ref2.isObjectType,
      isInterfaceType = _ref2.isInterfaceType,
      isUnionType = _ref2.isUnionType,
      usesFragments = _ref2.usesFragments,
      resolveInfo = _ref2.resolveInfo,
      orderByValue = _ref2.orderByValue,
      outerSkipLimit = _ref2.outerSkipLimit,
      typeMap = _ref2.typeMap;
  var cypherParams = (0, _translate.getCypherParams)(context);
  var safeVariableName = (0, _utils.safeVar)(variableName); // FIXME: support IN for multiple values -> WHERE

  var argString = (0, _utils.paramsToString)((0, _utils.innerFilterParams)((0, _utils.getFilterParams)(params.params || params), null, null, true), cypherParams);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var cypherQueryArg = mutationTypeCypherDirective.arguments.find(function (x) {
    return x.name.value === 'statement';
  });
  var rootStatement = cypherQueryArg.value.value;
  var nestedStatements = (0, _inputValues3.translateNestedMutations)({
    inputFields: args,
    parameterData: params,
    rootStatement: rootStatement,
    typeMap: typeMap
  });
  var cypherStatement = augmentCustomMutation({
    rootStatement: rootStatement,
    nestedStatements: nestedStatements
  });

  var _buildCypherSelection = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: cypherParams
  }),
      _buildCypherSelection2 = (0, _slicedToArray2["default"])(_buildCypherSelection, 2),
      subQuery = _buildCypherSelection2[0],
      subParams = _buildCypherSelection2[1];

  var isScalarType = (0, _utils.isGraphqlScalarType)(schemaType);
  var isNeo4jTypeOutput = (0, _utils.isNeo4jType)(schemaType.name);
  var isScalarField = isNeo4jTypeOutput || isScalarType;
  var orderByClause = orderByValue.cypherPart;
  var listVariable = "apoc.map.values(value, [keys(value)[0]])[0] ";

  var _buildMapProjection = (0, _translate.buildMapProjection)({
    isComputedMutation: true,
    listVariable: listVariable,
    schemaType: schemaType,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    isObjectType: isObjectType,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subQuery,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection2 = (0, _slicedToArray2["default"])(_buildMapProjection, 2),
      mapProjection = _buildMapProjection2[0],
      labelPredicate = _buildMapProjection2[1];

  var query = '';

  if (labelPredicate) {
    query = "CALL apoc.cypher.doIt(\"".concat(cypherStatement, "\", ").concat(argString, ") YIELD value\n    ").concat(!isScalarField ? labelPredicate : '', "AS ").concat(safeVariableName, "\n    RETURN ").concat(!isScalarField ? "".concat(mapProjection, " AS ").concat(safeVariableName).concat(orderByClause).concat(outerSkipLimit) : '');
  } else {
    query = "CALL apoc.cypher.doIt(\"".concat(cypherStatement, "\", ").concat(argString, ") YIELD value\n    WITH ").concat(listVariable, "AS ").concat(safeVariableName, "\n    RETURN ").concat(safeVariableName, " ").concat(!isScalarField ? "{".concat(isInterfaceType ? "".concat((0, _translate.fragmentType)(safeVariableName, schemaType.name), ",") : '').concat(subQuery, "} AS ").concat(safeVariableName).concat(orderByClause).concat(outerSkipLimit) : '');
  }

  var fragmentTypeParams = (0, _translate.derivedTypesParams)({
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    schema: resolveInfo.schema,
    schemaTypeName: schemaType.name,
    usesFragments: usesFragments
  });
  params = _objectSpread(_objectSpread(_objectSpread({}, params), subParams), fragmentTypeParams);

  if (cypherParams) {
    params['cypherParams'] = cypherParams;
  }

  return [query, _objectSpread({}, params)];
};

var augmentCustomMutation = function augmentCustomMutation(_ref3) {
  var _ref3$rootStatement = _ref3.rootStatement,
      rootStatement = _ref3$rootStatement === void 0 ? '' : _ref3$rootStatement,
      _ref3$nestedStatement = _ref3.nestedStatements,
      nestedStatements = _ref3$nestedStatement === void 0 ? '' : _ref3$nestedStatement;
  var augmented = rootStatement;

  if (nestedStatements) {
    var statement = rootStatement.replace(/\r?\n|\r/g, ' ');
    var newlinedWithClauses = statement.replace(/\r?RETURN|\r/gi, "\nRETURN");
    var splitOnClause = newlinedWithClauses.split('\n');
    var returnClauseIndex = splitOnClause.length - 1;
    var returnClause = splitOnClause[returnClauseIndex];
    var endsWithReturnClause = returnClause.startsWith('RETURN'); // require that the root @cypher statement have a RETURN clause

    if (endsWithReturnClause) {
      var rootWithClause = "WITH *";

      var _returnClause = splitOnClause.splice(returnClauseIndex, 1, rootWithClause); // add the existent nested mutations


      splitOnClause.push(nestedStatements);
      splitOnClause.push(_returnClause[0]);
    }

    augmented = splitOnClause.join('\n');
  }

  return augmented;
};

var nodeCreate = function nodeCreate(_ref4) {
  var resolveInfo = _ref4.resolveInfo,
      schemaType = _ref4.schemaType,
      selections = _ref4.selections,
      params = _ref4.params,
      context = _ref4.context,
      variableName = _ref4.variableName,
      typeName = _ref4.typeName,
      additionalLabels = _ref4.additionalLabels,
      typeMap = _ref4.typeMap;
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var dataArgument = args.find(function (arg) {
    return arg.name.value === 'data';
  });
  var paramKey = 'params';
  var dataParams = params[paramKey];
  var nestedStatements = ''; // handle differences with experimental input object argument format

  if (dataArgument) {
    // config.experimental
    var unwrappedType = (0, _fields.unwrapNamedType)({
      type: dataArgument.type
    });
    var name = unwrappedType.name;
    var inputType = typeMap[name];
    var inputValues = inputType.getFields(); // get the input value AST definitions of the .data input object
    // use the .data key instead of the existing .params format

    paramKey = 'data';
    dataParams = dataParams[paramKey]; // elevate .data to top level so it matches "data" argument

    params = _objectSpread(_objectSpread(_objectSpread({}, params), params.params), {}, {
      data: dataParams
    }); // remove .params entry

    delete params.params; // translate nested mutations discovered in input object arguments

    nestedStatements = (0, _inputValues3.translateNestedMutations)({
      inputFields: args,
      parameterData: params,
      typeMap: typeMap
    });
    args = (0, _values["default"])(inputValues).map(function (arg) {
      return arg.astNode;
    });
  } else {
    // translate nested mutations discovered in input object arguments
    nestedStatements = (0, _inputValues3.translateNestedMutations)({
      inputFields: args,
      parameterData: dataParams,
      paramVariable: paramKey,
      typeMap: typeMap
    });
  } // use apoc.create.uuid() to set a default value for @id field,
  // if no value for it is provided in dataParams


  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var primaryKeyStatement = (0, _utils.setPrimaryKeyValue)({
    args: args,
    params: dataParams,
    primaryKey: primaryKey
  }); // build Cypher for root CREATE statement

  var safeVariableName = (0, _utils.safeVar)(variableName);
  var safeLabelName = (0, _utils.safeLabel)([typeName].concat((0, _toConsumableArray2["default"])(additionalLabels)));
  var paramStatements = (0, _utils.buildCypherParameters)({
    args: args,
    statements: primaryKeyStatement,
    params: params,
    paramKey: paramKey,
    resolveInfo: resolveInfo,
    typeMap: typeMap
  });
  var createStatement = "CREATE (".concat(safeVariableName, ":").concat(safeLabelName, " {").concat(paramStatements.join(','), "})"); // translate selection set

  var _buildCypherSelection3 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: (0, _translate.getCypherParams)(context)
  }),
      _buildCypherSelection4 = (0, _slicedToArray2["default"])(_buildCypherSelection3, 2),
      subQuery = _buildCypherSelection4[0],
      subParams = _buildCypherSelection4[1];

  params = _objectSpread(_objectSpread({}, params), subParams);
  var translation = "".concat(createStatement).concat(nestedStatements ? "\n  WITH *\n  ".concat(nestedStatements) : '');
  var query = "\n    ".concat(translation, "\n    RETURN ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName, "\n  ");
  return [query, params];
};

var nodeMergeOrUpdate = function nodeMergeOrUpdate(_ref5) {
  var resolveInfo = _ref5.resolveInfo,
      variableName = _ref5.variableName,
      typeName = _ref5.typeName,
      selections = _ref5.selections,
      schemaType = _ref5.schemaType,
      additionalLabels = _ref5.additionalLabels,
      params = _ref5.params,
      context = _ref5.context,
      typeMap = _ref5.typeMap;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var paramKey = 'params';
  var dataParams = params[paramKey];
  var nestedStatements = '';
  var selectionArgument = args.find(function (arg) {
    return arg.name.value === 'where';
  });
  var dataArgument = args.find(function (arg) {
    return arg.name.value === 'data';
  });
  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var primaryKeyArgName = primaryKey.name.value;
  var cypherOperation = '';
  var safeLabelName = (0, _utils.safeLabel)(typeName);

  if ((0, _utils.isMergeMutation)(resolveInfo)) {
    safeLabelName = (0, _utils.safeLabel)([typeName].concat((0, _toConsumableArray2["default"])(additionalLabels)));
    cypherOperation = 'MERGE';
  } else if ((0, _utils.isUpdateMutation)(resolveInfo)) {
    cypherOperation = 'MATCH';
  }

  var query = "";
  var paramUpdateStatements = [];

  if (selectionArgument && dataArgument) {
    // config.experimental
    // no need to use .params key in this argument design
    params = dataParams;

    var _translateNodeInputAr = translateNodeInputArgument({
      selectionArgument: selectionArgument,
      dataArgument: dataArgument,
      params: params,
      primaryKey: primaryKey,
      typeMap: typeMap,
      fieldMap: fieldMap,
      resolveInfo: resolveInfo,
      context: context
    }),
        _translateNodeInputAr2 = (0, _slicedToArray2["default"])(_translateNodeInputAr, 2),
        propertyStatements = _translateNodeInputAr2[0],
        generatePrimaryKey = _translateNodeInputAr2[1];

    var onMatchStatements = "";

    if (propertyStatements.length > 0) {
      onMatchStatements = "SET ".concat((0, _utils.safeVar)(variableName), " += {").concat(propertyStatements.join(','), "} ");
    }

    if ((0, _utils.isMergeMutation)(resolveInfo)) {
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: selectionArgument.type
      });
      var name = unwrappedType.name;
      var inputType = typeMap[name];
      var inputValues = inputType.getFields();
      var selectionArgs = (0, _values["default"])(inputValues).map(function (arg) {
        return arg.astNode;
      });
      var selectionExpression = (0, _utils.buildCypherParameters)({
        args: selectionArgs,
        params: params,
        paramKey: 'where',
        resolveInfo: resolveInfo,
        cypherParams: (0, _translate.getCypherParams)(context),
        typeMap: typeMap
      });
      var onCreateProps = [].concat((0, _toConsumableArray2["default"])(propertyStatements), (0, _toConsumableArray2["default"])(generatePrimaryKey));
      var onCreateStatements = "";

      if (onCreateProps.length > 0) {
        onCreateStatements = "SET ".concat((0, _utils.safeVar)(variableName), " += {").concat(onCreateProps.join(','), "}");
      }

      var keySelectionStatement = selectionExpression.join(',');
      query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, "{").concat(keySelectionStatement, "})\nON CREATE\n  ").concat(onCreateStatements, "\nON MATCH\n  ").concat(onMatchStatements);
    } else {
      var _translateNodeSelecti = translateNodeSelectionArgument({
        variableName: variableName,
        args: args,
        params: params,
        schemaType: schemaType,
        resolveInfo: resolveInfo
      }),
          _translateNodeSelecti2 = (0, _slicedToArray2["default"])(_translateNodeSelecti, 2),
          predicate = _translateNodeSelecti2[0],
          serializedFilter = _translateNodeSelecti2[1];

      query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, ")").concat(predicate, "\n").concat(onMatchStatements, "\n");
      params = _objectSpread(_objectSpread({}, params), serializedFilter);
    }

    nestedStatements = (0, _inputValues3.translateNestedMutations)({
      inputFields: args,
      parameterData: dataParams,
      typeMap: typeMap
    });
  } else {
    nestedStatements = (0, _inputValues3.translateNestedMutations)({
      inputFields: args,
      parameterData: dataParams,
      paramVariable: paramKey,
      typeMap: typeMap
    });

    var _splitSelectionParame = (0, _utils.splitSelectionParameters)(params, primaryKeyArgName, paramKey),
        _splitSelectionParame2 = (0, _slicedToArray2["default"])(_splitSelectionParame, 2),
        primaryKeyParam = _splitSelectionParame2[0],
        updateParams = _splitSelectionParame2[1];

    paramUpdateStatements = (0, _utils.buildCypherParameters)({
      args: args,
      params: updateParams,
      paramKey: paramKey,
      resolveInfo: resolveInfo,
      cypherParams: (0, _translate.getCypherParams)(context),
      typeMap: typeMap
    });
    query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, "{").concat(primaryKeyArgName, ": $params.").concat(primaryKeyArgName, "})\n  ");

    if (paramUpdateStatements.length > 0) {
      query += "SET ".concat(safeVariableName, " += {").concat(paramUpdateStatements.join(','), "} ");
    }

    if (!params.params) params.params = {};
    params.params[primaryKeyArgName] = primaryKeyParam[primaryKeyArgName];
  }

  var _buildCypherSelection5 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: (0, _translate.getCypherParams)(context)
  }),
      _buildCypherSelection6 = (0, _slicedToArray2["default"])(_buildCypherSelection5, 2),
      subQuery = _buildCypherSelection6[0],
      subParams = _buildCypherSelection6[1];

  params = _objectSpread(_objectSpread({}, params), subParams);
  query = "".concat(query).concat(nestedStatements ? "\n  WITH *\n  ".concat(nestedStatements) : '', "RETURN ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName);
  return [query, params];
};

var nodeDelete = function nodeDelete(_ref6) {
  var resolveInfo = _ref6.resolveInfo,
      selections = _ref6.selections,
      variableName = _ref6.variableName,
      typeName = _ref6.typeName,
      schemaType = _ref6.schemaType,
      typeMap = _ref6.typeMap,
      params = _ref6.params;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var safeLabelName = (0, _utils.safeLabel)(typeName);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var primaryKeyArgName = primaryKey.name.value;
  var matchStatement = "";
  var selectionArgument = args.find(function (arg) {
    return arg.name.value === 'where';
  });

  if (selectionArgument) {
    var _translateNodeSelecti3 = translateNodeSelectionArgument({
      variableName: variableName,
      args: args,
      params: params,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }),
        _translateNodeSelecti4 = (0, _slicedToArray2["default"])(_translateNodeSelecti3, 2),
        predicate = _translateNodeSelecti4[0],
        serializedFilter = _translateNodeSelecti4[1];

    matchStatement = "MATCH (".concat(safeVariableName, ":").concat(safeLabelName, ")").concat(predicate);
    params = _objectSpread(_objectSpread({}, params), serializedFilter);
  } else {
    matchStatement = "MATCH (".concat(safeVariableName, ":").concat(safeLabelName, " {").concat(primaryKeyArgName, ": $").concat(primaryKeyArgName, "})");
  }

  var nestedStatements = (0, _inputValues3.translateNestedMutations)({
    inputFields: args,
    parameterData: params,
    typeMap: typeMap
  });

  var _buildCypherSelection7 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo
  }),
      _buildCypherSelection8 = (0, _slicedToArray2["default"])(_buildCypherSelection7, 2),
      subQuery = _buildCypherSelection8[0],
      subParams = _buildCypherSelection8[1];

  params = _objectSpread(_objectSpread({}, params), subParams);
  var deletionVariableName = (0, _utils.safeVar)("".concat(variableName, "_toDelete"));
  var query = '';

  if (nestedStatements) {
    // Cannot execute a map projection on a deleted node in Neo4j
    // so the projection is executed and aliased before the delete
    query = "".concat(matchStatement, "\n").concat(nestedStatements, "\nWITH ").concat(safeVariableName, " AS ").concat(deletionVariableName, ", ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName, "\nDETACH DELETE ").concat(deletionVariableName, "\nRETURN ").concat(safeVariableName);
  } else {
    // Cannot execute a map projection on a deleted node in Neo4j
    // so the projection is executed and aliased before the delete
    query = "".concat(matchStatement, "\nWITH ").concat(safeVariableName, " AS ").concat(deletionVariableName, ", ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName, "\nDETACH DELETE ").concat(deletionVariableName, "\nRETURN ").concat(safeVariableName);
  }

  return [query, params];
};

var translateNodeInputArgument = function translateNodeInputArgument(_ref7) {
  var _ref7$selectionArgume = _ref7.selectionArgument,
      selectionArgument = _ref7$selectionArgume === void 0 ? {} : _ref7$selectionArgume,
      _ref7$dataArgument = _ref7.dataArgument,
      dataArgument = _ref7$dataArgument === void 0 ? {} : _ref7$dataArgument,
      params = _ref7.params,
      primaryKey = _ref7.primaryKey,
      typeMap = _ref7.typeMap,
      resolveInfo = _ref7.resolveInfo,
      context = _ref7.context;
  var unwrappedType = (0, _fields.unwrapNamedType)({
    type: dataArgument.type
  });
  var name = unwrappedType.name;
  var inputType = typeMap[name];
  var inputValues = inputType.getFields();
  var updateArgs = (0, _values["default"])(inputValues).map(function (arg) {
    return arg.astNode;
  });
  var propertyStatements = (0, _utils.buildCypherParameters)({
    args: updateArgs,
    params: params,
    paramKey: 'data',
    resolveInfo: resolveInfo,
    cypherParams: (0, _translate.getCypherParams)(context),
    typeMap: typeMap
  });
  var primaryKeyStatement = [];

  if ((0, _utils.isMergeMutation)(resolveInfo)) {
    var _unwrappedType = (0, _fields.unwrapNamedType)({
      type: selectionArgument.type
    });

    var _name = _unwrappedType.name;
    var _inputType = typeMap[_name];

    var _inputValues = _inputType.getFields();

    var selectionArgs = (0, _values["default"])(_inputValues).map(function (arg) {
      return arg.astNode;
    }); // check key selection values for @id key argument

    var primaryKeySelectionValue = (0, _utils.setPrimaryKeyValue)({
      args: selectionArgs,
      params: params['where'],
      primaryKey: primaryKey
    });
    var primaryKeyValue = (0, _utils.setPrimaryKeyValue)({
      args: updateArgs,
      params: params['data'],
      primaryKey: primaryKey
    });

    if (primaryKeySelectionValue.length && primaryKeyValue.length) {
      // apoc.create.uuid() statement returned for both, so a value exists in neither
      primaryKeyStatement = primaryKeySelectionValue;
    }
  }

  return [propertyStatements, primaryKeyStatement];
};

var translateNodeSelectionArgument = function translateNodeSelectionArgument(_ref8) {
  var variableName = _ref8.variableName,
      args = _ref8.args,
      params = _ref8.params,
      schemaType = _ref8.schemaType,
      resolveInfo = _ref8.resolveInfo;

  var _processFilterArgumen = (0, _translate.processFilterArgument)({
    argumentName: 'where',
    fieldArgs: args,
    schemaType: schemaType,
    variableName: variableName,
    resolveInfo: resolveInfo,
    params: params
  }),
      _processFilterArgumen2 = (0, _slicedToArray2["default"])(_processFilterArgumen, 2),
      filterPredicates = _processFilterArgumen2[0],
      serializedFilter = _processFilterArgumen2[1];

  var predicateClauses = (0, _toConsumableArray2["default"])(filterPredicates).filter(function (predicate) {
    return !!predicate;
  }).join(' AND ');
  var predicate = "";

  if ((0, _utils.isMergeMutation)(resolveInfo)) {
    predicate = predicateClauses;
  } else {
    predicate = predicateClauses ? " WHERE ".concat(predicateClauses, " ") : '';
  }

  return [predicate, serializedFilter];
}; // Relation Add / Remove


var relationshipCreate = function relationshipCreate(_ref9) {
  var _parentSelectionInfo;

  var resolveInfo = _ref9.resolveInfo,
      selections = _ref9.selections,
      schemaType = _ref9.schemaType,
      params = _ref9.params,
      context = _ref9.context;
  var mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;

  try {
    mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
      return x.name.value === 'MutationMeta';
    });
  } catch (e) {
    throw new Error('Missing required MutationMeta directive on add relationship directive');
  }

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  var schemaTypeName = (0, _utils.safeVar)(schemaType);
  var cypherParams = (0, _translate.getCypherParams)(context);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var typeMap = resolveInfo.schema.getTypeMap();
  var fromType = fromTypeArg.value.value;
  var fromSchemaType = resolveInfo.schema.getType(fromType);
  var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(fromSchemaType, cypherParams);
  var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
  var firstArg = args[0];
  var fromArgName = firstArg.name.value;
  var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
  var fromVariable = (0, _utils.safeVar)(fromVar);
  var fromInputArg = firstArg.type;
  var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
  var fromInputAst = typeMap[fromInputArgType].astNode;
  var fromFields = fromInputAst.fields;
  var fromCypherParam = fromFields[0].name.value;
  var toType = toTypeArg.value.value;
  var toSchemaType = resolveInfo.schema.getType(toType);
  var toAdditionalLabels = (0, _utils.getAdditionalLabels)(toSchemaType, cypherParams);
  var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
  var secondArg = args[1];
  var toArgName = secondArg.name.value;
  var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
  var toVariable = (0, _utils.safeVar)(toVar);
  var toInputArg = secondArg.type;
  var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
  var toInputAst = typeMap[toInputArgType].astNode;
  var toFields = toInputAst.fields;
  var toCypherParam = toFields[0].name.value;
  var relationshipName = relationshipNameArg.value.value;
  var lowercased = relationshipName.toLowerCase();
  var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
  var relationshipVariable = (0, _utils.safeVar)(lowercased + '_relation');
  var dataInputArg = args.find(function (e) {
    return e.name.value === 'data';
  });
  var dataInputAst = dataInputArg ? typeMap[(0, _graphql.getNamedType)(dataInputArg.type).type.name.value].astNode : undefined;
  var dataFields = dataInputAst ? dataInputAst.fields : [];

  var _buildCypherSelection9 = (0, _selections.buildCypherSelection)({
    selections: selections,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    parentSelectionInfo: (_parentSelectionInfo = {
      fromArgName: fromArgName,
      toArgName: toArgName
    }, (0, _defineProperty2["default"])(_parentSelectionInfo, fromArgName, fromVar), (0, _defineProperty2["default"])(_parentSelectionInfo, toArgName, toVar), (0, _defineProperty2["default"])(_parentSelectionInfo, "variableName", lowercased), _parentSelectionInfo),
    cypherParams: (0, _translate.getCypherParams)(context)
  }),
      _buildCypherSelection10 = (0, _slicedToArray2["default"])(_buildCypherSelection9, 2),
      subQuery = _buildCypherSelection10[0],
      subParams = _buildCypherSelection10[1];

  var nodeSelectionStatements = "";
  var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
  var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

  if (fromUsesWhereInput && toUsesWhereInput) {
    var _processFilterArgumen3 = (0, _translate.processFilterArgument)({
      argumentName: fromArgName,
      variableName: fromVar,
      schemaType: fromSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen4 = (0, _slicedToArray2["default"])(_processFilterArgumen3, 2),
        fromPredicate = _processFilterArgumen4[0],
        serializedFromFilter = _processFilterArgumen4[1];

    var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');

    var _processFilterArgumen5 = (0, _translate.processFilterArgument)({
      argumentName: toArgName,
      variableName: toVar,
      schemaType: toSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen6 = (0, _slicedToArray2["default"])(_processFilterArgumen5, 2),
        toPredicate = _processFilterArgumen6[0],
        serializedToFilter = _processFilterArgumen6[1];

    var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');
    var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
    var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
    params = _objectSpread(_objectSpread({}, params), serializedFromFilter);
    params = _objectSpread(_objectSpread({}, params), serializedToFilter);
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
  } else {
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
  }

  var paramStatements = (0, _utils.buildCypherParameters)({
    args: dataFields,
    params: params,
    paramKey: 'data',
    resolveInfo: resolveInfo,
    typeMap: typeMap
  });
  params = _objectSpread(_objectSpread({}, params), subParams);
  var query = "\n      ".concat(nodeSelectionStatements, "\n      CREATE (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel).concat(paramStatements.length > 0 ? " {".concat(paramStatements.join(','), "}") : '', "]->(").concat(toVariable, ")\n      RETURN ").concat(relationshipVariable, " { ").concat(subQuery, " } AS ").concat(schemaTypeName, ";\n    ");
  return [query, params];
};

var relationshipDelete = function relationshipDelete(_ref10) {
  var _parentSelectionInfo2;

  var resolveInfo = _ref10.resolveInfo,
      selections = _ref10.selections,
      schemaType = _ref10.schemaType,
      params = _ref10.params,
      context = _ref10.context;
  var mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;

  try {
    mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
      return x.name.value === 'MutationMeta';
    });
  } catch (e) {
    throw new Error('Missing required MutationMeta directive on add relationship directive');
  }

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  var schemaTypeName = (0, _utils.safeVar)(schemaType);
  var cypherParams = (0, _translate.getCypherParams)(context);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var typeMap = resolveInfo.schema.getTypeMap();
  var fromType = fromTypeArg.value.value;
  var fromSchemaType = resolveInfo.schema.getType(fromType);
  var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromType), cypherParams);
  var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
  var firstArg = args[0];
  var fromArgName = firstArg.name.value;
  var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
  var fromVariable = (0, _utils.safeVar)(fromVar);
  var fromInputArg = firstArg.type;
  var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
  var fromInputAst = typeMap[fromInputArgType].astNode;
  var fromFields = fromInputAst.fields;
  var fromCypherParam = fromFields[0].name.value;
  var toType = toTypeArg.value.value;
  var toSchemaType = resolveInfo.schema.getType(toType);
  var toAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toType), cypherParams);
  var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
  var secondArg = args[1];
  var toArgName = secondArg.name.value;
  var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
  var toVariable = (0, _utils.safeVar)(toVar);
  var toInputArg = secondArg.type;
  var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
  var toInputAst = typeMap[toInputArgType].astNode;
  var toFields = toInputAst.fields;
  var toCypherParam = toFields[0].name.value;
  var relationshipName = relationshipNameArg.value.value;
  var relationshipVariable = (0, _utils.safeVar)(fromVar + toVar);
  var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
  var nodeSelectionStatements = "";
  var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
  var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

  if (fromUsesWhereInput && toUsesWhereInput) {
    var _processFilterArgumen7 = (0, _translate.processFilterArgument)({
      argumentName: fromArgName,
      variableName: fromVar,
      schemaType: fromSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen8 = (0, _slicedToArray2["default"])(_processFilterArgumen7, 2),
        fromPredicate = _processFilterArgumen8[0],
        serializedFromFilter = _processFilterArgumen8[1];

    var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');

    var _processFilterArgumen9 = (0, _translate.processFilterArgument)({
      argumentName: toArgName,
      variableName: toVar,
      schemaType: toSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen10 = (0, _slicedToArray2["default"])(_processFilterArgumen9, 2),
        toPredicate = _processFilterArgumen10[0],
        serializedToFilter = _processFilterArgumen10[1];

    var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');
    var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
    var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
    params = _objectSpread(_objectSpread({}, params), serializedFromFilter);
    params = _objectSpread(_objectSpread({}, params), serializedToFilter);
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
  } else {
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
  }

  var _buildCypherSelection11 = (0, _selections.buildCypherSelection)({
    selections: selections,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    parentSelectionInfo: (_parentSelectionInfo2 = {
      fromArgName: fromArgName,
      toArgName: toArgName
    }, (0, _defineProperty2["default"])(_parentSelectionInfo2, fromArgName, '_' + fromVar), (0, _defineProperty2["default"])(_parentSelectionInfo2, toArgName, '_' + toVar), _parentSelectionInfo2),
    cypherParams: (0, _translate.getCypherParams)(context)
  }),
      _buildCypherSelection12 = (0, _slicedToArray2["default"])(_buildCypherSelection11, 2),
      subQuery = _buildCypherSelection12[0],
      subParams = _buildCypherSelection12[1];

  var query = "\n      ".concat(nodeSelectionStatements, "\n      OPTIONAL MATCH (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel, "]->(").concat(toVariable, ")\n      DELETE ").concat(relationshipVariable, "\n      WITH COUNT(*) AS scope, ").concat(fromVariable, " AS ").concat((0, _utils.safeVar)("_".concat(fromVar)), ", ").concat(toVariable, " AS ").concat((0, _utils.safeVar)("_".concat(toVar)), "\n      RETURN {").concat(subQuery, "} AS ").concat(schemaTypeName, ";\n    ");
  params = _objectSpread(_objectSpread({}, params), subParams);
  return [query, params];
};

var relationshipMergeOrUpdate = function relationshipMergeOrUpdate(_ref11) {
  var mutationMeta = _ref11.mutationMeta,
      resolveInfo = _ref11.resolveInfo,
      selections = _ref11.selections,
      schemaType = _ref11.schemaType,
      params = _ref11.params,
      context = _ref11.context;
  var query = '';
  var relationshipNameArg = undefined;
  var fromTypeArg = undefined;
  var toTypeArg = undefined;

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  if (relationshipNameArg && fromTypeArg && toTypeArg) {
    var _parentSelectionInfo3;

    var schemaTypeName = (0, _utils.safeVar)(schemaType);
    var cypherParams = (0, _translate.getCypherParams)(context);
    var args = (0, _utils.getMutationArguments)(resolveInfo);
    var typeMap = resolveInfo.schema.getTypeMap();
    var fromType = fromTypeArg.value.value;
    var fromSchemaType = resolveInfo.schema.getType(fromType);
    var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromType), cypherParams);
    var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
    var firstArg = args[0];
    var fromArgName = firstArg.name.value;
    var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
    var fromVariable = (0, _utils.safeVar)(fromVar);
    var fromInputArg = firstArg.type;
    var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
    var fromInputAst = typeMap[fromInputArgType].astNode;
    var fromFields = fromInputAst.fields;
    var fromCypherParam = fromFields[0].name.value;
    var toType = toTypeArg.value.value;
    var toSchemaType = resolveInfo.schema.getType(toType);
    var toAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toType), cypherParams);
    var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
    var secondArg = args[1];
    var toArgName = secondArg.name.value;
    var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
    var toVariable = (0, _utils.safeVar)(toVar);
    var toInputArg = secondArg.type;
    var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
    var toInputAst = typeMap[toInputArgType].astNode;
    var toFields = toInputAst.fields;
    var toCypherParam = toFields[0].name.value;
    var relationshipName = relationshipNameArg.value.value;
    var lowercased = relationshipName.toLowerCase();
    var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
    var relationshipVariable = (0, _utils.safeVar)(lowercased + '_relation');
    var dataInputArg = args.find(function (e) {
      return e.name.value === 'data';
    });
    var dataInputAst = dataInputArg ? typeMap[(0, _graphql.getNamedType)(dataInputArg.type).type.name.value].astNode : undefined;
    var dataFields = dataInputAst ? dataInputAst.fields : [];
    var nodeSelectionStatements = "";
    var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
    var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

    if (fromUsesWhereInput && toUsesWhereInput) {
      var _processFilterArgumen11 = (0, _translate.processFilterArgument)({
        argumentName: fromArgName,
        variableName: fromVar,
        schemaType: fromSchemaType,
        fieldArgs: args,
        resolveInfo: resolveInfo,
        params: params
      }),
          _processFilterArgumen12 = (0, _slicedToArray2["default"])(_processFilterArgumen11, 2),
          fromPredicate = _processFilterArgumen12[0],
          serializedFromFilter = _processFilterArgumen12[1];

      var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
        return !!predicate;
      }).join(' AND ');

      var _processFilterArgumen13 = (0, _translate.processFilterArgument)({
        argumentName: toArgName,
        variableName: toVar,
        schemaType: toSchemaType,
        fieldArgs: args,
        resolveInfo: resolveInfo,
        params: params
      }),
          _processFilterArgumen14 = (0, _slicedToArray2["default"])(_processFilterArgumen13, 2),
          toPredicate = _processFilterArgumen14[0],
          serializedToFilter = _processFilterArgumen14[1];

      var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
        return !!predicate;
      }).join(' AND ');
      var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
      var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
      params = _objectSpread(_objectSpread({}, params), serializedFromFilter);
      params = _objectSpread(_objectSpread({}, params), serializedToFilter);
      nodeSelectionStatements = "  MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
    } else {
      nodeSelectionStatements = "  MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
    }

    var _buildCypherSelection13 = (0, _selections.buildCypherSelection)({
      selections: selections,
      schemaType: schemaType,
      resolveInfo: resolveInfo,
      parentSelectionInfo: (_parentSelectionInfo3 = {
        fromArgName: fromArgName,
        toArgName: toArgName
      }, (0, _defineProperty2["default"])(_parentSelectionInfo3, fromArgName, fromVar), (0, _defineProperty2["default"])(_parentSelectionInfo3, toArgName, toVar), (0, _defineProperty2["default"])(_parentSelectionInfo3, "variableName", lowercased), _parentSelectionInfo3),
      cypherParams: (0, _translate.getCypherParams)(context)
    }),
        _buildCypherSelection14 = (0, _slicedToArray2["default"])(_buildCypherSelection13, 2),
        subQuery = _buildCypherSelection14[0],
        subParams = _buildCypherSelection14[1];

    var paramStatements = (0, _utils.buildCypherParameters)({
      args: dataFields,
      params: params,
      paramKey: 'data',
      resolveInfo: resolveInfo,
      typeMap: typeMap
    });
    var cypherOperation = '';

    if ((0, _utils.isMergeMutation)(resolveInfo)) {
      cypherOperation = 'MERGE';
    } else if ((0, _utils.isUpdateMutation)(resolveInfo)) {
      cypherOperation = 'MATCH';
    }

    query = "\n    ".concat(nodeSelectionStatements, "\n      ").concat(cypherOperation, " (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel, "]->(").concat(toVariable, ")").concat(paramStatements.length > 0 ? "\n      SET ".concat(relationshipVariable, " += {").concat(paramStatements.join(','), "} ") : '', "\n      RETURN ").concat(relationshipVariable, " { ").concat(subQuery, " } AS ").concat(schemaTypeName, ";\n    ");
    params = _objectSpread(_objectSpread({}, params), subParams);
  }

  return [query, params];
};

var getUnionLabels = function getUnionLabels(_ref12) {
  var _ref12$typeName = _ref12.typeName,
      typeName = _ref12$typeName === void 0 ? '' : _ref12$typeName,
      _ref12$typeMap = _ref12.typeMap,
      typeMap = _ref12$typeMap === void 0 ? {} : _ref12$typeMap;
  var unionLabels = [];
  (0, _keys["default"])(typeMap).map(function (key) {
    var definition = typeMap[key];
    var astNode = definition.astNode;

    if ((0, _types.isUnionTypeDefinition)({
      definition: astNode
    })) {
      var types = definition.getTypes();
      var unionTypeName = definition.name;

      if (types.find(function (type) {
        return type.name === typeName;
      })) {
        unionLabels.push(unionTypeName);
      }
    }
  });
  return unionLabels;
};